# 12 CLOS的亮点

在本章中，我们将讨论 CLOS 的最初设计目标，以及它们是如何实现的。 我们解决了 CLOS 的三个重要设计目标和一个非目标：

+ CLOS 应该是一个标准的语言扩展，包含了现有的面向对象范式中最有用的方面

+ CLOS 程序员接口应该足够强大和灵活，可以开发大多数应用程序

+ CLOS 本身应该被设计为一个可扩展的协议，以允许对其行为进行定制并鼓励进一步研究面向对象编程

+ CLOS 不应该为指定和执行协议提供自动支持

第三个目标引出了 CLOS 的一个高级主题——元对象协议。 我们介绍元对象协议的动机并简要讨论它。

## 12.1 设计标准的面向对象范例

在设计 CLOS 时（从 1986 年开始），许多面向对象的范式已经在各种 Lisp 实现中用了好几年。 设计 CLOS 的目标是定义 Common Lisp 的标准语言扩展。 这个标准的直接好处是使 Lisp 程序员能够以面向对象的风格编写可移植的代码。 

许多现有的面向对象范式有重要的相似之处。 CLOS 工作组希望将这些范式中最有用的方面收集到一个单一的、统一的语言扩展中。 从一开始，工作组就同意定义语言标准的主要目标是保守的——在 CLOS 标准中只包含那些被很好理解的特性和技术。 工作组试图根据现有范式的优势定义一个一致的模型，同时排除不必要的特征。

## 12.2 程序员接口概要

这里我们总结一下CLOS程序员接口支持的主要技术：

+ 定义类的组织。 您可以方便地定义类的组织。 类从其直接超类继承结构和行为，这些超类以列表的形式包含在 `defclass` 表达式中。 CLOS 根据 `defclass` 表达式中本地指定的约束自动计算得出一个类优先级列表。

+ 创建和初始化实例。 您可以使用 `make-instance` 创建实例。 CLOS 为您提供了对实例初始化方式的良好控制。 您可以指定一个槽应该用一个 initarg 填充，并且你可以为槽和 initargs 提供默认初始值。 您可以通过专门化`initialize-instance`来执行进一步的初始化。

+ 定义不同类别的方法。 您可以为许多不同的目的定义方法，包括： 

  - 专门化读取器和写入器方法
  - 针对 COMMON LISP 的类型专门化
  - 针对不止一个参数(multi-methods)专门化
  - 针对单个 LISP 对象专门化
  
+ 定义协同工作的方法。 泛型调度（标准方法组合类型）的默认行为允许不同角色的方法，包括 primary 方法、before 方法、after 方法和 around 方法。 这是一个极其灵活的框架，与类继承机制一起——使您能够在模块中定义代码。 根据泛型函数的参数和方法的角色，每个模块都会在适当的时候发挥作用。

+ 使用不同的框架进行泛型调度。 您可以轻松地使用其中一种内置方法组合类型，或基于 Lisp 函数、宏或特殊形式定义新的方法组合类型。 使用其他方法组合类型的自由允许您控制方法的调用方式以及对它的值的处理方式。

+ 动态重新定义元素。 您可以即时地重新定义泛型函数、方法和类。 即使在类的实例存在之后，您也可以重新定义类。 CLOS 确保所有受重定义影响的东西都会自动更新，包括实例、子类和子类的实例。 更新实例时，默认方法根据新定义添加或删除槽，并保留未更改的槽的值。 您可以通过专门更新实例结构在重新定义期间执行进一步的操作。

这些特征加起来具有很大的表现力。 然而，“满足大多数应用程序”的目标需要权衡取舍。 为了满足大多数应用程序，程序员接口非常灵活。 这种灵活性的缺点是 CLOS 用户可能会被各种各样的技术和要学习的特性所淹没。 此外，CLOS 通常支持不止一种方式来做一件事情，而且对于哪种方式更可取，并不总是有一个明确的指导方针。

当然，编写一个大型应用程序并不需要了解所有这些技术。 任何单个程序都只需要这些技术的一个子集。 我们鼓励新用户集中精力学习 CLOS 如何工作的核心主题，尤其是泛型调度。 如果您知道了调用泛型函数时会发生什么，那么您就顺利完成了。 下一步是开始编写 CLOS 程序。 在开发过程中，你可能会发现用最基本的 CLOS 特征（如primary methods、before-methods、after-methods）无法方便解决的问题，然后你可以研究更高级的特征 （如 around 方法，或其他类型的方法组合）。

## 12.3 探索替代范式

到目前为止提到的所有表达能力，还需要什么？ CLOS 程序员接口支持一种面向对象编程模型，但也有其他范式。

例如，在 CLOS 中，一个类几乎继承了其超类的所有方面：槽、一些槽和类选项以及方法。 我们可以称之为“开放共享”： 默认情况下，类几乎继承了所有内容，但如果需要，可以选择覆盖某些继承的行为或特征。 另一种范式可能支持“封闭共享”，其中一个类默认情况下不从其超类继承任何内容，但可以明确指定它想要继承其超类的哪些方面。

任何面向对象范式的另外两个关键方面是如何指定类的组织，以及如何控制这些类之间的优先级。 在 CLOS 中，程序员以 `defclass` 形式指定类的组织； 每个类都有一个超类列表。 这些超类的顺序对类的优先级设置了局部约束。 CLOS 使用一种算法来计算每个类的类优先级列表，该列表始终与局部约束集一致。 这只是控制继承的许多可能方法之一。

在定义 CLOS 时，大多数对一种或多种现有范式有经验的开发人员都同意面向对象编程对于设计和实现大型系统至关重要。 然而，即使是“面向对象编程”这个短语对不同的人也有不同的含义。 每个单独的范式不仅发明了自己的语法，还发明了自己的语义。

工作组必须做出某些决定和选择，以便将 CLOS 定义为一个一致的模型。 工作组还认为，鼓励对替代范式进行持续试验很重要。 解决方案是将 CLOS 本身定义和记录为可扩展的协议，称为元对象协议。 我们在第 219 页的“CLOS 元对象协议”中对此进行了讨论。

## 12.4 非目标：自动协议支持

一些面向对象的范例积极地协助程序员指定协议。 类的定义可以描述类的更多语义。 例如，类定义可以声明该类仅用作构建块，并且不应创建它的实例。 类的要求可以在类定义中明确说明。 例如，诸如 `ordered-lock-mixin` 之类的 `mixin` 类有一些隐含的要求：它旨在与另一个锁类（例如 `simple-lock` 或 `null-lock`）一起用作构建块，并且该锁类必须 提供锁协议的方法。 一些面向对象的语言提供了一种明确说明这些要求并强制执行它们的方法。

CLOS 不提供对协议的自动支持。 工作组认为这是一个试验性领域，尚未准备好进行标准化。

在本书中，我们将协议的主题作为设计程序的一种有价值的手段。 尽管 CLOS 并不积极支持协议，但它仍然是一种有助于定义它们的语言。 CLOS 使协议定义方便的方面是泛型函数不是由特殊语法调用的事实。 对于调用者来说，普通函数和泛型函数之间没有明显的区别。 在其他面向对象的范例中，调用者必须知道函数是普通函数还是泛型函数，以便选择适当的调用语法。 调用语法的不同掩盖了接口和实现之间的本质区别。

目前，定义协议的工具是文档。 我们建议为外部协议提供文档并将其宣传给客户。 对于大型应用程序，记录内部协议并将其宣传给程序的开发人员和维护人员也很有用。 有时，内部协议被隐式定义为未在外部协议中公布的一组操作符。

虽然 CLOS 本身不支持协议，但工作组认为协议是有价值和重要的。 CLOS 本身被记录为可扩展的协议。 CLOS 程序员接口的基础在于元对象协议，该协议被记录以允许研究人员和开发人员尝试其他面向对象的范例。

## 12.5 CLOS元对象协议

本节简要概述元对象协议——足以让您了解它与 CLOS 程序-程序员接口的关系。

**CLOS元素的类**

CLOS 的一个重要方面是每个 Lisp 对象都是一个类的实例。 这意味着类对象本身有一个类，方法对象和泛型函数对象也是如此。 CLOS 使用术语元类来表示作为类的类的类。 以下是三个预定义的元类：

+ `standard-class`: `defclass` 定义的类对象的默认类。
+ `built-in-class`: 以特殊方式（不是通过 `defclass`）实现的类对象的类。 大多数对应于 Common Lisp 类型说明符的类对象都被实现为内置类的实例，尽管其他类对象可能被实现为标准类的实例。 
+ `structure-class`: 当没有给出 `:type` 选项时，`defstruct` 定义的类对象的类。

在描述元类是`standard-class`的类时，我们使用了非正式术语“用户定义类”。 类似地，术语“内置类”表示其元类是`build-in-class`的类。 元类对用户很重要，因为它决定了类的行为。 例如，`standard-class`支持 `make-instance`，但内置类不支持。 也就是说，CLOS提供了`make-instance`附加到`standard-class`的方法，但是没有`make-instance`附加到`built-in-class`的方法。 

CLOS 扩展了 `defstruct` 以使您能够为 `defstruct` 结构编写方法。 如果你使用 `defstruct` 而不给出 `:type` 选项，`defstruct` 结构被实现为一个元类是`structure-class`的类。 这样做的好处是您可以为该类编写方法。 然而，如果你需要编写方法的话，使用 `defclass` 可能比使用 `defstruct` 更好。 一方面，使用 `defclass` 使您摆脱了单一继承的限制。 此外，`standard-class`支持重新定义类的灵活性，但`structure-class`或`built-in-class`不支持。

CLOS 使用术语 *元对象* 来表示表示 CLOS 元素的对象，例如类对象、方法对象和泛型函数对象。 下面是两个预定义的元对象类：

+ `standard-method`: 使用`defmethod`定义的方法对象的缺省类
+ `standard-generic-function`: 使用`defgeneric`定义的泛型函数对象的缺省类

基本的 CLOS 元素本身作为 CLOS 元素实现，因此我们看到类、泛型函数和方法遵循 CLOS 模型。 类（或泛型函数或方法）的结构和行为由其类定义。 预定义的元对象类具有支持 CLOS 的默认行为的方法。

对于大多数 CLOS 应用程序，CLOS 的默认行为足够强大和灵活，无需知道或关心类、方法和泛型函数本身就是类的实例。 对其他面向对象范式感兴趣的程序员可以使用 CLOS 作为实验的基础。 程序员可以定义新的元类（通常建立在标准元类之上），以支持类的新的和不同的行为。 程序员还可以将新的元对象类定义为泛型函数或方法的类。 这是 CLOS 的一个附加级别，称为元对象级别。 它是函数级别的基础，而函数级别又是宏级别的基础。

除了促进研究和实验之外，元对象级别还可以开发用于浏览或分析 CLOS 程序的工具。 元对象协议描述了如何获取有关用户定义的 CLOS 元素的信息： 可以查询类对象的类优先级列表、槽和 `defclass` 选项； 可以查询泛型函数对象的方法集。 信息是可用的，浏览器和环境工具可以设计方法将其有效地呈现给 CLOS 程序员。

| CLOS 级 | 处理 | 使用环境 |
| -------- | -------- | -------------------- |
| 宏        | 名字      | 大多数 CLOS 应用       |
| 函数      | 对象      | 使用匿名对象的程序       |
| 元对象    | 元对象    | 工具、研究、实验        |

**类，超类，元类**

讨论元类给 CLOS 模型增加了一定程度的复杂性。 甚至连术语也令人困惑。 在这里，我们做了一些陈述，应该有助于阐明类、超类和元类-元类的含义。 CLOS 应用程序编程中使用了以下概念：

+ 每一个 Lisp 对象都是某个类的实例。 您可以使用 `(class-of object)` 来找出对象的类。

+ 对象的类决定了它的结构和行为。 给定类的所有实例都具有相同的槽集合。 任何专门针对给定类的方法都适用于该类的所有实例。

+ 一个类有一组超类。 类从其超类继承结构和行为。 换句话说，附加到类的方法适用于该类的子类的实例。

以下是 CLOS 元对象编程的概念。 请注意，这些概念中的每一个都是应用程序编程中使用的概念的自然扩展。

+ 因为每个 Lisp 对象都是一个类的实例，所以一个类对象本身就是一个类的实例。 您可以使用 `(class-of class-object)` 找出类对象的类。 类对象的类术语是“元类”。 换句话说，元类的实例是类对象。

+ 类对象的类（元类）决定了该类对象的结构和行为。 给定元类的所有类都具有相同的槽集。 专门针对给定元类的方法适用于该元类的所有类对象。

+ 一个类有一组超类。 类从其超类继承结构和行为。 因为元类是一个类，它也可以具有继承结构和行为的超类。 换句话说，附加到元类的方法适用于该元类的子类的实例。

**元对象编程**

CLOS 规范记录了一组预定义的元对象及其遵循的协议。 开发人员可以使用这些元对象作为出发点。 要支持具有完全不同行为的类，您可以定义一个新的元类。 您可以通过定义基于标准类的类来稍微修改默认行为； 这样，您可以在继承其他方面的同时覆盖行为的某些方面。
